package main

// The following directive is necessary to make the package coherent:
// +build ignore

import (
	"flag"
	"fmt"
	"log"
	"os"
	"text/template"
)

const materialTemplate = `package three
// Code generated by go generate; DO NOT EDIT.
//
// using the following cmd:
// material_method_generator -materialName {{ .MaterialName }} -materialSlug {{ .MaterialSlug }}

import (
	"github.com/fatih/structs"
	"github.com/gopherjs/gopherjs/js"
)
	
func (m {{ .MaterialName }}) OnBeforeCompile() {
	m.Call("onBeforeCompile")
}

func (m {{ .MaterialName }}) SetValues(values MaterialParameters) {
	m.Call("setValues", structs.Map(values))
}

func (m {{ .MaterialName }}) ToJSON(meta interface{}) interface{} {
	return m.Call("toJSON", meta)
}

func (m {{ .MaterialName }}) Clone() {
	m.Call("clone")
}

func (m {{ .MaterialName }}) Copy(source Object3D) {
	m.Call("copy", source)
}

func (m {{ .MaterialName }}) Dispose() {
	m.Call("dispose")
}

func (m {{ .MaterialName }}) getInternalObject() *js.Object {
	return m.Object
}

`

var (
	materialName = flag.String("materialName", "", "Name of class that extends Material e.g. MeshBasicMaterial")
	materialSlug = flag.String("materialSlug", "", "Slugified name of class e.g. mesh_basic_material")
)

func main() {
	flag.Parse()

	if *materialName == "" {
		log.Fatal("a material name argument must be provided (e.g. -materialName MeshBasicMaterial)")
	}
	if *materialSlug == "" {
		log.Fatal("a material slug argument must be provided (e.g. -materialSlug mesh_basic_material)")
	}

	filePath := fmt.Sprintf("./gen_material_%s.go", *materialSlug)

	f, err := os.Create(filePath)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	err = template.Must(template.New("").Parse(materialTemplate)).Execute(f, struct {
		MaterialName string
		MaterialSlug string
	}{
		MaterialName: *materialName,
		MaterialSlug: *materialSlug,
	})
	if err != nil {
		log.Fatal(err)
	}

	log.Printf("Generated file: %s", filePath)
}
